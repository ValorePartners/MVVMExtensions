{"Name":"ServiceStack.Text","Id":1567,"Alias":"servicestacktext","Description":"ServiceStack.Text is an **independent, dependency-free** serialization library that contains ServiceStack\u0027s text processing functionality, including:\r\n\r\n* [JsonSerializer](http://www.servicestack.net/mythz_blog/?p=344)\r\n* [TypeSerializer (JSV-Format)](https://github.com/ServiceStack/ServiceStack.Text/wiki/JSV-Format)\r\n* CsvSerializer\r\n* [T.Dump extension method](http://www.servicestack.net/mythz_blog/?p=202)\r\n* StringExtensions - Xml/Json/Csv/Url encoding, BaseConvert, Rot13, Hex escape, etc.\r\n* Stream, Reflection, List, DateTime, etc extensions and utils\r\n\r\n# Simple API\r\n\r\nLike most of the interfaces in Service Stack, the API is simple. Methods that you would commonly use include:\r\n\r\n    string TypeSerializer.SerializeToString\u003cT\u003e(T value)\r\n    void TypeSerializer.SerializeToWriter\u003cT\u003e(T value, TextWriter writer)\r\n\r\n    T TypeSerializer.DeserializeFromString\u003cT\u003e(string value)\r\n    T TypeSerializer.DeserializeFromReader\u003cT\u003e(TextReader reader)\r\n\r\nWhere *T* can be any .NET POCO type. That\u0027s all there is - the API was intentionally left simple :)\r\n    \r\n### Dynamic JSON parsing API\r\n\r\n    JsonObject.Parse()\r\n    JsonArrayObjects.Parse()\r\n\r\n### Extension Methods\r\n\r\n    T FromJson()\r\n    string ToJson(T)\r\n\r\n    T FromJsv()\r\n    string ToJsv(T)\r\n\r\nDump / Diagnostic Extensions:\r\n\r\n    T Dump()\r\n    T Print()\r\n    T PrintDump()\r\n    string Fmt(args)\r\n\r\nURL Extensions:\r\n\r\n    string GetStringFromUrl()\r\n    string GetJsonFromUrl()\r\n    string GetResponseStatus()\r\n    string UrlEncode() / UrlDecode()\r\n    string HexEscape() / HexUnescape()\r\n    string UrlFormat() / AppendPath() / AppendPaths() / WithTrailingSlash()    \r\n    string WithoutExtension() / ParentDirectory() / ReadAllText()\r\n\r\nStream Extensions:\r\n\r\n    Stream WriteTo(Stream) / CopyTo()\r\n    StreamReader ReadLines()\r\n    Stream ReadFully() / ReadExactly()\r\n\r\nString Utils:\r\n\r\n    string SplitOnFirst() / SplitOnLast()\r\n    string IndexOfAny()\r\n    string StripHtml() / ToCamelCase()\r\n    string SafeSubstring()\r\n    string ToUtf8Bytes() / FromUtf8Bytes()\r\n\r\nmore String, Reflection, List, Dictionary, DateTime extensions, and More...","Version":"3.9.61.3","Summary":".NET\u0027s fastest JSON, JSV and CSV Text Serializers","QuickStart":"For simple conversions to and from JSON strings and .NET objects, ServiceStack.Text provides handy extension methods to Deserialize and Serialize Objects.\r\n\r\n```csharp\r\nusing ServiceStack.Text;\r\n...\r\n\r\npublic class Person\r\n{\r\n    public string Name { get; set; }\r\n    public string LastName { get; set; }\r\n}\r\n\r\nvoid PersonToJsonToPersonExample ()\r\n{\r\n    // Object to Json\r\n\tvar person = new Person { Name = \"John\", LastName = \"Doe\" };\r\n\tvar json = person.ToJson ();\r\n\tConsole.WriteLine (\"JSON representation of person: {0}\", json);\r\n\r\n\t//Json to Object\r\n\tvar john = json.FromJson\u003cPerson\u003e ();\r\n\tConsole.WriteLine (\"Name: {0} LastName: {1}\", john.Name, john.LastName);\r\n}\r\n```\r\n\r\n## T.Dump() Extension method\r\nAnother useful library to have in your .NET toolbox is the [T.Dump() Extension Method](http://www.servicestack.net/mythz_blog/?p=202). Under the hood it uses a *Pretty Print* Output of the JSV Format to recursively dump the contents of any .NET object. Example usage and output: \r\n\r\n\tvar model = new TestModel();\r\n\tConsole.WriteLine(model.Dump());\r\n\r\n\t//Example Output\r\n\t{\r\n\t\tInt: 1,\r\n\t\tString: One,\r\n\t\tDateTime: 2010-04-11,\r\n\t\tGuid: c050437f6fcd46be9b2d0806a0860b3e,\r\n\t\tEmptyIntList: [],\r\n\t\tIntList:\r\n\t\t[\r\n\t\t\t1,\r\n\t\t\t2,\r\n\t\t\t3\r\n\t\t],\r\n\t\tStringList:\r\n\t\t[\r\n\t\t\tone,\r\n\t\t\ttwo,\r\n\t\t\tthree\r\n\t\t],\r\n\t\tStringIntMap:\r\n\t\t{\r\n\t\t\ta: 1,\r\n\t\t\tb: 2,\r\n\t\t\tc: 3\r\n\t\t}\r\n\t}\r\n\r\n# ServiceStack\u0027s JsonSerializer\r\n\r\nServiceStack\u0027s JsonSerializer is optimized for serializing C# POCO types in and out of JSON as fast, compact and cleanly as possible. In most cases C# objects serializes as you would expect them to without added json extensions or serializer-specific artefacts.\r\n\r\nJsonSerializer provides a simple API that allows you to serialize any .NET generic or runtime type into a string, TextWriter/TextReader or Stream.\r\n\r\n### Serialization API\r\n\r\n\tstring SerializeToString\u003cT\u003e(T)\r\n\tvoid SerializeToWriter\u003cT\u003e(T, TextWriter)\r\n\tvoid SerializeToStream\u003cT\u003e(T, Stream)\r\n\tstring SerializeToString(object, Type)\r\n\tvoid SerializeToWriter(object, Type, TextWriter)\r\n\tvoid SerializeToStream(object, Type, Stream)\r\n\r\n### Deserialization API\r\n\r\n\tT DeserializeFromString\u003cT\u003e(string)\r\n\tT DeserializeFromReader\u003cT\u003e(TextReader)\r\n\tobject DeserializeFromString(string, Type)\r\n\tobject DeserializeFromReader(reader, Type)\r\n\tobject DeserializeFromStream(Type, Stream)\r\n\tT DeserializeFromStream\u003cT\u003e(Stream)\r\n\r\n### Extension methods\r\n\r\n\tstring ToJson\u003cT\u003e(this T)\r\n\tT FromJson\u003cT\u003e(this string)\r\n\r\nConvenient **ToJson/FromJson** extension methods are also included reducing the amount of code required, e.g:\r\n\r\n\tnew []{ 1, 2, 3 }.ToJson()   //= [1,2,3]\r\n\t\"[1,2,3]\".FromJson\u003cint[]\u003e()  //= int []{ 1, 2, 3 }\r\n\r\n## JSON Format \r\n\r\nJSON is a lightweight text serialization format with a spec that\u0027s so simple that it fits on one page: [http://www.json.org](json.org).\r\n\r\nThe only valid values in JSON are:\r\n\r\n  * string\r\n  * number\r\n  * object\r\n  * array\r\n  * true\r\n  * false\r\n  * null\r\n\r\nWhere most allowed values are scalar and the only complex types available are objects and arrays. Although limited, the above set of types make a good fit and can express most programming data structures.\r\n\r\n### number, true, false types\r\n\r\nAll C# boolean and numeric data types are stored as-is without quotes.\r\n\r\n### null type\r\n\r\nFor the most compact output null values are omitted from the serialized by default. If you want to include null values set the global configuration:\r\n\r\n\tJsConfig.IncludeNullValues = true;\r\n\r\n### string type\r\n\r\nAll other scalar values are stored as strings that are surrounded with double quotes.\r\n\r\n### C# Structs and Value Types\r\n\r\nBecause a C# struct is a value type whose public properties are normally just convenience properties around a single scalar value, they are ignored instead the **TStruct.ToString()** method is used to serialize and either the **static TStruct.ParseJson()**/**static TStruct.ParseJsv()** methods or **new TStruct(string)** constructor will be used to deserialize the value type if it exists.\r\n\r\n### array type\r\n\r\nAny List, Queue, Stack, Array, Collection, Enumerables including custom enumerable types are stored in exactly the same way as a JavaScript array literal, i.e:\r\n\r\n\t[1,2,3,4,5]\r\n\r\nAll elements in an array must be of the same type. If a custom type is both an IEnumerable and has properties it will be treated as an array and the extra properties will be ignored.\r\n\r\n### object type\r\n\r\nThe JSON object type is the most flexible and is how most complex .NET types are serialized. The JSON object type is a key-value pair JavaScript object literal where the key is always a double-quoted string.\r\n\r\nAny IDictionary is serialized into a standard JSON object, i.e:\r\n\r\n\t{\"A\":1,\"B\":2,\"C\":3,\"D\":4}\r\n\r\nWhich happens to be the same as C# POCO types (inc. Interfaces) with the values:\r\n\r\n`new MyClass { A=1, B=2, C=3, D=4 }`\r\n\r\n\t{\"A\":1,\"B\":2,\"C\":3,\"D\":4}\r\n\r\nOnly public properties on reference types are serialized with the C# Property Name used for object key and the Property Value as the value. At the moment it is not possible to customize the Property Name.\r\n\r\nJsonSerializer also supports serialization of anonymous types in much the same way:\r\n\r\n`new { A=1, B=2, C=3, D=4 }`\r\n\r\n\t{\"A\":1,\"B\":2,\"C\":3,\"D\":4}\r\n\r\n\r\n## Custom Serialization\r\n\r\nAlthough JsonSerializer is optimized for serializing .NET POCO types, it still provides some options to change the convention-based serialization routine.\r\n\r\n### Using Structs to Customize JSON\r\n\r\nThis makes it possible to customize the serialization routine and provide an even more compact wire format. \r\n\r\nE.g. Instead of using a JSON object to represent a point \r\n\r\n\t{ Width=20, Height=10 }\r\n\t\r\nYou could use a struct and reduce it to just: \r\n\r\n\t\"20x10\" \r\n\r\nBy overriding **ToString()** and providing a static **Size ParseJson()** method:\r\n\r\n\tpublic struct Size\r\n\t{\r\n\t\tpublic double Width { get; set; }\r\n\t\tpublic double Height { get; set; }\r\n\r\n\t\tpublic override string ToString()\r\n\t\t{\r\n\t\t\treturn Width + \"x\" + Height;\r\n\t\t}\r\n\r\n\t\tpublic static Size ParseJson(string json)\r\n\t\t{\r\n\t\t\tvar size = json.Split(\u0027x\u0027);\r\n\t\t\treturn new Size { \r\n\t\t\t\tWidth = double.Parse(size[0]), \r\n\t\t\t\tHeight = double.Parse(size[1]) \r\n\t\t\t};\r\n\t\t}\r\n\t}\r\n\r\nWhich would change it to the more compact JSON output:\r\n\r\n\tnew Size { Width = 20, Height = 10 }.ToJson() // = \"20x10\"\r\n\r\nThat allows you to deserialize it back in the same way:\r\n\r\n\tvar size = \"20x10\".FromJson\u003cSize\u003e(); \r\n\r\n### Using Custom IEnumerable class to serialize a JSON array\r\n\r\nIn addition to using a Struct you can optionally use a custom C# IEnumerable type to provide a strong-typed wrapper around a JSON array:\r\n\r\n\tpublic class Point : IEnumerable\r\n\t{\r\n\t\tdouble[] points = new double[2];\r\n\t\r\n\t\tpublic double X \r\n\t\t{\r\n\t\t\tget { return points[0]; }\r\n\t\t\tset { points[0] = value; }\r\n\t\t}\r\n\t\r\n\t\tpublic double Y\r\n\t\t{\r\n\t\t\tget { return points[1]; }\r\n\t\t\tset { points[1] = value; }\r\n\t\t}\r\n\t\r\n\t\tpublic IEnumerator GetEnumerator()\r\n\t\t{\r\n\t\t\tforeach (var point in points) \r\n\t\t\t\tyield return point;\r\n\t\t}\r\n\t}\r\n\r\nWhich serializes the Point into a compact JSON array:\r\n\r\n\tnew Point { X = 1, Y = 2 }.ToJson() // = [1,2]\r\n\r\n### Custom Serialization Routines\r\n\r\nIf you can\u0027t change the definition of a ValueType (e.g. because its in the BCL), you can assign a custom serialization /\r\ndeserialization routine to use instead. E.g. here\u0027s how you can add support for `System.Drawing.Color`:\r\n\r\n    JsConfig\u003cSystem.Drawing.Color\u003e.SerializeFn = c =\u003e c.ToString().Replace(\"Color \",\"\").Replace(\"[\",\"\").Replace(\"]\",\"\");\r\n    JsConfig\u003cSystem.Drawing.Color\u003e.DeSerializeFn = System.Drawing.Color.FromName;\r\n\r\n## Custom Deserialization\r\n\r\nBecause the same wire format shared between Dictionaries, POCOs and anonymous types, in most cases what you serialize with one type can be deserialized with another, i.e. an Anonymous type can be deserialized back into a Dictionary\u003cstring,string\u003e which can be deserialized into a strong-typed POCO and vice-versa.\r\n\r\nAlthough the JSON Serializer is best optimized for serializing and deserializing .NET types, it\u0027s flexible enough to consume 3rd party JSON apis although this generally requires custom de-serialization to convert it into an idiomatic .NET type.\r\n\r\n[GitHubRestTests.cs](https://github.com/ServiceStack/ServiceStack.Text/blob/master/tests/ServiceStack.Text.Tests/UseCases/GitHubRestTests.cs)\r\n\r\n  1. Using [JsonObject](https://github.com/ServiceStack/ServiceStack.Text/blob/master/src/ServiceStack.Text/JsonObject.cs)\r\n  2. Using Generic .NET Collection classes\r\n  3. Using Customized DTO\u0027s in the shape of the 3rd party JSON response\r\n\r\n[CentroidTests](https://github.com/ServiceStack/ServiceStack.Text/blob/master/tests/ServiceStack.Text.Tests/UseCases/CentroidTests.cs) is another example that uses the JsonObject to parse a complex custom JSON response. \r\n\r\n\r\n#TypeSerializer Details (JSV Format)\r\n\r\nOut of the box .NET provides a fairly quick but verbose Xml DataContractSerializer or a slightly more compact but slower JsonDataContractSerializer. \r\nBoth of these options are fragile and likely to break with any significant schema changes. \r\nTypeSerializer addresses these shortcomings by being both smaller and significantly faster than the most popular options. \r\nIt\u0027s also more resilient, e.g. a strongly-typed POCO object can be deserialized back into a loosely-typed string Dictionary and vice-versa.\r\n\r\nWith that in mind, TypeSerializer\u0027s main features are:\r\n\r\n - Fastest and most compact text-serializer for .NET\r\n - Human readable and writeable, self-describing text format\r\n - Non-invasive and configuration-free\r\n - Resilient to schema changes\r\n - Serializes / De-serializes any .NET data type (by convention)\r\n   + Supports custom, compact serialization of structs by overriding `ToString()` and `static T Parse(string)` methods\r\n   + Can serialize inherited, interface or \u0027late-bound objects\u0027 data types\r\n   + Respects opt-in DataMember custom serialization for DataContract dto types.\r\n\r\nThese characteristics make it ideal for use anywhere you need to store or transport .NET data-types, e.g. for text blobs in a ORM, data in and out of a key-value store or as the text-protocol in .NET to .NET web services.  \r\n \r\nAs such, it\u0027s utilized within ServiceStack\u0027s other components:\r\n - OrmLite - to store complex types on table models as text blobs in a database field and\r\n - [ServiceStack.Redis](https://github.com/ServiceStack/ServiceStack.Redis) - to store rich POCO data types into the very fast [redis](http://code.google.com/p/redis) instances.\r\n\r\nYou may also be interested in the very useful [T.Dump() extension method](http://www.servicestack.net/mythz_blog/?p=202) for recursively viewing the contents of any C# POCO Type.\r\n\r\n---\r\n\r\n# JSV Text Format (JSON + CSV)\r\n\r\nType Serializer uses a hybrid CSV-style escaping + JavaScript-like text-based format that is optimized for both size and speed. I\u0027m naming this JSV-format (i.e. JSON + CSV) \r\n\r\nIn many ways it is similar to JavaScript, e.g. any List, Array, Collection of ints, longs, etc are stored in exactly the same way, i.e:\r\n\t[1,2,3,4,5]\r\n\r\nAny IDictionary is serialized like JavaScript, i.e:\r\n\t{A:1,B:2,C:3,D:4}\r\n\r\nWhich also happens to be the same as C# POCO class with the values \r\n\r\n`new MyClass { A=1, B=2, C=3, D=4 }`\r\n\r\n\t{A:1,B:2,C:3,D:4}\r\n\r\nJSV is *white-space significant*, which means normal string values can be serialized without quotes, e.g: \r\n\r\n`new MyClass { Foo=\"Bar\", Greet=\"Hello World!\"}` is serialized as:\r\n\r\n\t{Foo:Bar,Greet:Hello World!}\r\n\r\n\r\n### CSV escaping\r\n\r\nAny string with any of the following characters: `[]{},\"`\r\nis escaped using CSV-style escaping where the value is wrapped in double quotes, e.g:\r\n\r\n`new MyClass { Name = \"Me, Junior\" }` is serialized as:\r\n\t\r\n\t{Name:\"Me, Junior\"}\r\n\r\nA value with a double-quote is escaped with another double quote e.g:\r\n\r\n`new MyClass { Size = \"2\\\" x 1\\\"\" }` is serialized as:\r\n\r\n\t{Size:\"2\"\" x 1\"\"\"}\r\n\r\n\r\n## Rich support for resilience and schema versioning\r\nTo better illustrate the resilience of `TypeSerializer` and the JSV Format check out a real world example of it when it\u0027s used to [Painlessly migrate between old and new types in Redis](https://github.com/ServiceStack/ServiceStack.Redis/wiki/MigrationsUsingSchemalessNoSql). \r\n\r\nSupport for dynamic payloads and late-bound objects is explained in the post [Versatility of JSV Late-bound objects](http://www.servicestack.net/mythz_blog/?p=314).\r\n\r\n\r\n# Community Resources\r\n\r\n  - [ServiceStack.Text has nice extension method called Dump and has a few friends](http://blogs.lessthandot.com/index.php/DesktopDev/MSTech/servicestack-text-has-a-nice) by [@chrissie1](https://twitter.com/chrissie1)\r\n  - [JSON.NET vs ServiceStack](http://daniel.wertheim.se/2011/02/07/json-net-vs-servicestack/)\r\n","Hash":"9b691d9776392627c25354da244598d9","TargetPlatforms":["ios","android"],"TrialHash":null}